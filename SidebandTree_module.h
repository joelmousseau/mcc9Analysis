
#include <fstream>
#include <sstream>
#include <iostream>
#include <stdlib.h>
#include <string>
#include <vector>

#include "lardataobj/AnalysisBase/T0.h"
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "lardataobj/AnalysisBase/Calorimetry.h"
#include "lardataobj/AnalysisBase/ParticleID.h"
#include "larreco/RecoAlg/TrackMomentumCalculator.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Optional/TFileDirectory.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "canvas/Utilities/InputTag.h"
#include "canvas/Persistency/Common/Wrapper.h"
#include "canvas/Persistency/Common/FindMany.h"
#include "canvas/Persistency/Common/FindOne.h"
#include "canvas/Persistency/Common/FindManyP.h"
#include "canvas/Persistency/Common/FindOneP.h"
#include "canvas/Persistency/Common/PtrVector.h"
#include "lardataobj/MCBase/MCShower.h"
#include "larsim/MCCheater/ParticleInventoryService.h"
#include "larsim/EventWeight/Base/MCEventWeight.h"
#include "larsim/MCCheater/BackTrackerService.h"
#include "larsim/Simulation/LArG4Parameters.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "nusimdata/SimulationBase/GTruth.h"
#include "nusimdata/SimulationBase/MCParticle.h"
#include "lardataobj/RecoBase/OpFlash.h"
#include "lardataobj/RecoBase/Shower.h"
#include "lardataobj/RecoBase/Cluster.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/RecoBase/Vertex.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/RecoBase/PFParticle.h"
#include "lardataobj/AnalysisBase/BackTrackerMatchingData.h"
#include "larcore/Geometry/Geometry.h"
#include "larcoreobj/SimpleTypesAndConstants/geo_types.h"
#include "larcorealg/Geometry/PlaneGeo.h"
#include "larcorealg/Geometry/CryostatGeo.h"
#include "larcorealg/Geometry/WireGeo.h"
#include "larcorealg/Geometry/TPCGeo.h"
#include "lardata/Utilities/GeometryUtilities.h"
#include "lardata/ArtDataHelper/MVAReader.h"
#include "larreco/RecoAlg/EMShowerAlg.h"
#include "lardata/Utilities/GeometryUtilities.h"
#include "lardata/DetectorInfoServices/LArPropertiesService.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "lardata/DetectorInfoServices/DetectorClocksService.h"
#include "lardata/Utilities/UtilException.h"
#include "time.h"
#include "lardataobj/RecoBase/Hit.h"
#include "larcorealg/Geometry/GeometryCore.h"
#include "larcoreobj/SimpleTypesAndConstants/geo_types.h"
#include "lardataobj/RecoBase/PFParticleMetadata.h"
#include "canvas/Persistency/Common/Ptr.h"
#include <climits>
#include <iostream>
#include <vector>
#include "TGeoMatrix.h"
#include "TInterpreter.h"
#include "TROOT.h"
#include "TFile.h"
#include "TCanvas.h"
#include "TStyle.h"
#include "TTree.h"
#include "TH1F.h"
#include "TH1D.h"
#include "TH1I.h"
#include "TH2F.h"
#include "TF1.h"
#include "TTree.h"
#include "TEfficiency.h"
#include "TGraphAsymmErrors.h"
#include <TMath.h>
#include <TLorentzVector.h>
#include "ubobj/ubobj/UBXSec/SelectionResult.h"
#include "lardataobj/RecoBase/MCSFitResult.h"
#include "ubobj/ubobj/UBXSec/TPCObject.h"
//#include "ubcore/ubcore/LLBasicTool/GeoAlgo/GeoTrajectory.h"
//#include "ubcore/ubcore/LLBasicTool/GeoAlgo/GeoAABox.h"
//#include "ubcore/ubcore/LLBasicTool/GeoAlgo/GeoVector.h"
#include "larcoreobj/SummaryData/POTSummary.h"

class SidebandTree;

class SidebandTree : public art::EDAnalyzer {
public:
  explicit SidebandTree(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.
  
  // Plugins should not be copied or assigned.
  SidebandTree(SidebandTree const &) = delete;
  SidebandTree(SidebandTree &&) = delete;
  SidebandTree & operator = (SidebandTree const &) = delete;
  SidebandTree & operator = (SidebandTree &&) = delete;
  
 // Required functions.
  void analyze(art::Event const & e) override;
  void beginJob() override;
  void endSubRun(art::SubRun const & sr) override;
  void endJob() override;
  
  //general
  bool inFV(double x, double y, double z);
  double getPhi(double px, double py, double pz);

  //calorimetry
  int bestPlane(std::vector<art::Ptr<recob::Hit>> hits);
  float showerEnergy(int plane, std::vector<art::Ptr<recob::Hit>> hits);
  float showerEnergyDataGain(int plane, std::vector<art::Ptr<recob::Hit>> hits);
  double QtoEConversion(double Q);
  double getMedian(std::vector<double> thisvector);
  double getAmalgamateddEdx(double angle_wrt_plane0, double angle_wrt_plane1, double angle_wrt_plane2, double median_plane0, double median_plane1, double median_plane2, int plane0_nhits, int plane1_nhits, int plane2_nhits);
  double degToRad(double deg);
  double radToDeg(double rad);
  double getAnglewrtWires(TVector3 shower_dir,int plane);
  //std::vector<double> CalcdQdxShower(const art::Ptr<recob::Shower>& shower, const std::vector<art::Ptr<recob::Cluster>> & clusters, std::map<art::Ptr<recob::Cluster>, std::vector<art::Ptr<recob::Hit>> > &  clusterToHitMap ,int plane);
  std::vector<double> CalcdQdxShower(const art::Ptr<recob::Shower>& shower, const art::Ptr<recob::Cluster>& thiscluster, std::vector<art::Ptr<recob::Hit>> hits,  int plane, float trunklength);
  double GetQHit(art::Ptr<recob::Hit> thishitptr, int plane);
  double getPitch(TVector3 shower_dir, int plane);
  TVector3 getWireVec(int plane);
  double getCoswrtWires(TVector3 shower_dir, TVector3 wire_dir);
  std::vector<std::vector<double>> buildRectangle(std::vector<double> cluster_start, std::vector<double> cluster_axis, double width, double length);
  bool isInsidev2(std::vector<double> thishit_pos, std::vector<std::vector<double >> rectangle, float trunklength);
  double areaTriangle(double x1, double y1, double x2, double y2, double x3, double y3);

  //truth
  void checkMatchedGammas(art::Event const & e, art::InputTag allhits_tag, std::vector<art::Ptr<recob::Hit>> all_hits, std::vector<art::Ptr<recob::Hit>> shower_hits, art::InputTag hitparticleassns_tag, int plane, int Gamma_id, std::vector<art::Ptr<simb::MCParticle>> TwoGammaV, int& samedaughters, int& otherdaughters);
  double getPurity(art::Event const & e, art::InputTag allhits_tag, std::vector<art::Ptr<recob::Hit>> all_hits, std::vector<art::Ptr<recob::Hit>> shower_hits, std::vector<art::Ptr<simb::MCParticle>> all_mcparticles, std::vector<art::Ptr<simb::MCParticle>> Gamma1_descendents, std::vector<art::Ptr<simb::MCParticle>> Gamma2_descendents, int Gamma1_id, int Gamma2_id, art::InputTag hitparticleassns_tag, int plane);
  double getComplete(art::Event const & e, art::InputTag allhits_tag, std::vector<art::Ptr<recob::Hit>> all_hits, std::vector<art::Ptr<recob::Hit>> shower_hits, std::vector<art::Ptr<simb::MCParticle>> all_mcparticles, std::vector<art::Ptr<simb::MCParticle>> Gamma1_descendents, std::vector<art::Ptr<simb::MCParticle>> Gamma2_descendents, int Gamma1_id, int Gamma2_id, art::InputTag hitparticleassns_tag, int plane);
  double getEnergyRes(art::Event const & e, art::InputTag allhits_tag, std::vector<art::Ptr<recob::Hit>> all_hits, std::vector<art::Ptr<recob::Hit>> shower_hits, std::vector<art::Ptr<simb::MCParticle>> all_mcparticles, int Gamma1_id, int Gamma2_id, float Gamma1_E, float Gamma2_E, float energy, art::InputTag hitparticleassns_tag, int plane);
  double getTrueEnergy(art::Event const & e, art::InputTag allhits_tag, std::vector<art::Ptr<recob::Hit>> all_hits, std::vector<art::Ptr<recob::Hit>> shower_hits, std::vector<art::Ptr<simb::MCParticle>> all_mcparticles, int Gamma1_id, int Gamma2_id, float Gamma1_E, float Gamma2_E, art::InputTag hitparticleassns_tag, int plane);
  double getTrueTrackComposition(art::Event const & e, art::InputTag allhits_tag, std::vector<art::Ptr<recob::Hit>> all_hits, std::vector<art::Ptr<recob::Hit>> track_hits, std::vector<art::Ptr<simb::MCParticle>> all_mcparticles, art::InputTag hitparticleassns_tag, int plane);
  double getTrueComposition(art::Event const & e, art::InputTag allhits_tag, std::vector<art::Ptr<recob::Hit>> all_hits, std::vector<art::Ptr<recob::Hit>> shower_hits, std::vector<art::Ptr<simb::MCParticle>> all_mcparticles, int Gamma1_id, int Gamma2_id, std::vector<art::Ptr<simb::MCParticle>> Gamma1_descendents, std::vector<art::Ptr<simb::MCParticle>> Gamma2_descendents, art::InputTag hitparticleassns_tag, int plane);
  void getKids(std::vector<art::Ptr<simb::MCParticle>> all_mcpart_vector, int mcpart_id, std::vector<art::Ptr<simb::MCParticle>>& mcpart_kids);
  void newEvaluation(art::Event const & e, art::InputTag allhits_tag, std::vector<art::Ptr<recob::Hit>> all_hits, std::vector<art::Ptr<recob::Hit>> shower_hits, std::vector<art::Ptr<simb::MCParticle>> Gamma1_descendents, std::vector<art::Ptr<simb::MCParticle>> Gamma2_descendents, art::InputTag hitparticleassns_tag, int plane, int& shower_mcparticleid, int& shower_mcparticleid2, float& shower_purity, float& shower_complete, float& reco_e, float& true_e, float& energy_res);
  void newTruth(art::Event const & e, art::InputTag allhits_tag, std::vector<art::Ptr<recob::Hit>> all_hits, std::vector<art::Ptr<recob::Hit>> shower_hits, std::vector<art::Ptr<simb::MCParticle>> Gamma1_descendents, std::vector<art::Ptr<simb::MCParticle>> Gamma2_descendents, art::InputTag hitparticleassns_tag, int plane, int& shower_mcparticleid, int& shower_mcparticleid2, float& gamma1_shower, float& gamma2_shower, float& gamma1_event, float& gamma2_event, float& allmc_shower);
  void getOverlayFraction(art::Event const & e, art::InputTag allhits_tag, std::vector<art::Ptr<recob::Hit>> all_hits, std::vector<art::Ptr<recob::Hit>> shower_hits, art::InputTag hitparticleassns_tag, int plane, float& overlay_fraction);
  void getOverlayEnergy(art::Event const & e, art::InputTag allhits_tag, std::vector<art::Ptr<recob::Hit>> all_hits, std::vector<art::Ptr<recob::Hit>> shower_hits, art::InputTag hitparticleassns_tag, int plane, float& overlay_energy);
  double depEnergy(art::Event const & e, art::InputTag allhits_tag, std::vector<art::Ptr<recob::Hit>> all_hits, std::vector<art::Ptr<simb::MCParticle>> MCdescendents, art::InputTag hitparticleassns_tag, int plane);
  float XOffset(float t);
  void getTrueParticle(art::Event const & e, art::InputTag allhits_tag, std::vector<art::Ptr<recob::Hit>> all_hits, std::vector<art::Ptr<recob::Hit>> shower_hits, art::InputTag hitparticleassns_tag, int plane, int& shower_mcparticleid, float& shower_mcenergy);
  void TrackFitdEdx(std::vector<art::Ptr<anab::Calorimetry>> trackcaloobjects, float trunklength, float &dedxU, float &dedxV, float &dedxY);
  void getdEdx(art::Event const & e, art::InputTag calo_tag, art::InputTag shower_tag, art::InputTag pfp_tag, art::InputTag track_tag, art::InputTag trackfitter_tag, art::InputTag cluster_tag, art::Ptr<recob::Shower> shower, std::vector<art::Ptr<recob::PFParticle>> nuPFParticles, std::vector<art::Ptr<recob::Track>> TrackFitterVector, int trackID, float trunklength, float trunkwidth, double& dedx0, double& dedx1, double& dedx2, double& amalgdedx);
  
  //pi0
  void altVertexAngles(float VtxX, float VtxY, float VtxZ, art::Ptr<recob::Shower> shower, double& DirX, double& DirY, double& DirZ);
  void altTrackAngles(float TrackX, float TrackY, float TrackZ, art::Ptr<recob::Shower> shower, double& DirX, double& DirY, double& DirZ);
  double impactParameter(art::Ptr<recob::Shower> shower1, art::Ptr<recob::Shower> shower2);
  double impactParameterWithTrack(art::Ptr<recob::Track> track, art::Ptr<recob::Shower> shower, bool flipped);
  double angleBetweenTwoShowers(art::Ptr<recob::Shower> shower1, art::Ptr<recob::Shower> shower2);
  double angleBetweenTrackShower(art::Ptr<recob::Track> track, art::Ptr<recob::Shower> shower, bool flipped);
  double conversionLength(float vx, float vy, float vz, float x, float y, float z);
  double pi0Mass(double energy1, double energy2, double angle);
  double pi0Momentum(double mass, double energy1, double energy2, double angle);
  double Altpi0Momentum(double energy1, double energy2, double angle);
  double pi0Angle(double p, double energy1, double energy2, art::Ptr<recob::Shower> gamma1, art::Ptr<recob::Shower> gamma2, double angle);
  double conversionDistance(art::Ptr<recob::Shower> shower, float vx, float vy, float vz);
  double radialAngle(art::Ptr<recob::Shower> shower, float vx, float vy, float vz);

  //event selection
  bool passesShowerCuts(double dist3d, double energy2, double ang3d);

  
private:

  art::InputTag fEventWeightTag;
  art::InputTag fMCTruthTag;
  art::InputTag fGTruthTag;
  art::InputTag fMCParticleTag;
  art::InputTag fTrackTag;
  art::InputTag fTrackFitterTag;
  art::InputTag fCaloTag;
  art::InputTag fShowerTag;
  art::InputTag fClusterTag;
  art::InputTag fPFParticleTag;
  art::InputTag fMCShowerTag;
  art::InputTag fHitTag;
  art::InputTag fHitPartAssnTag;
  art::InputTag fPFParticleMetadataTag;
  art::InputTag fMCSFitResultTag;
     
  bool fIsMC;
  bool fIsDirt;

  int nchargedpi;
  int nproton;
  int nneutron;
  int nmuon;
  int nneutralpi;
  int nelectron;
  int nother;

  float trunklength;
  float trunklength2;
  float trunkwidth;  
  
  //TREES
  TTree* _tree;
  int _run;
  int _subRun;
  double _pot;

  TTree* _eventtree;

  //Truth variables

  //Cross section systematics
  std::vector<float> _f_All_Genie_Weights;
  std::vector<float> _f_RPA_CCQE_Genie_Weights;
  std::vector<float> _f_XSecShape_CCMEC_Genie_Weights;
  std::vector<float> _f_AxFFCCQEshape_Genie_Weights;
  std::vector<float> _f_VecFFCCQEshape_Genie_Weights;
  std::vector<float> _f_DecayAngMEC_Genie_Weights;
  std::vector<float> _f_Theta_Delta2Npi_Genie_Weights;
  
  //Flux systematics
  std::vector<float> _f_expskin_FluxUnisim_Weights;
  std::vector<float> _f_horncurrent_FluxUnisim_Weights;
  std::vector<float> _f_kminus_PrimaryHadronNormalization_Weights;
  std::vector<float> _f_kplus_PrimaryHadronFeynmanScaling_Weights;
  std::vector<float> _f_kzero_PrimaryHadronSanfordWang_Weights;
  std::vector<float> _f_nucleoninexsec_FluxUnisim_Weights;
  std::vector<float> _f_nucleonqexsec_FluxUnisim_Weights;
  std::vector<float> _f_nucleontotxsec_FluxUnisim_Weights;
  std::vector<float> _f_piminus_PrimaryHadronSWCentralSplineVariation_Weights;
  std::vector<float> _f_pioninexsec_FluxUnisim_Weights;
  std::vector<float> _f_pionqexsec_FluxUnisim_Weights;
  std::vector<float> _f_piontotxsec_FluxUnisim_Weights;
  std::vector<float> _f_piplus_PrimaryHadronSWCentralSplineVariation_Weights;
  
  float _fCVWeight;
  int _fNuCCNC;
  int _fNuMode;
  float _fNuEnergy;
  float _fNuVtxX;
  float _fNuVtxY;
  float _fNuVtxZ;
  int _fNuPDG;
  int _fNuInFV;
  int _fResNum;

  int _fLepPdg;
  float _fLepP;
  float _fLepPx;
  float _fLepPy;
  float _fLepPz;
  float _fLepCosTheta;
  float _fLepPhi; 

  float _fPi0E;
  float _fPi0P;
  float _fPi0M;
  float _fPi0Px;
  float _fPi0Py;
  float _fPi0Pz;
  float _fPi0CosTheta;
  float _fPi0Phi;

  int _fNpi0;
  int _fNmuon;
  int _fNpiplus;
  int _fNproton;
  int _fNneutron;

  int _fGamma1_id;
  int _fGamma2_id;
  float _fGamma1_E;
  float _fGamma2_E;
  float _fGamma12_CosTheta;
  float _fGamma12_Angle;
  
  float _fGamma1_DirX;
  float _fGamma1_DirY;
  float _fGamma1_DirZ;
  
  float _fGamma2_DirX;
  float _fGamma2_DirY;
  float _fGamma2_DirZ;      
  
  int _fGamma1E1_id;
  int _fGamma1E2_id;
  int _fGamma2E1_id;
  int _fGamma2E2_id;

  //Count objects
  int _fNTracks;
  int _fNShowers;
  int _fNHitsU;
  int _fNHitsV;
  int _fNHitsY;

  //flash chi2 of neutrino for RW
  float _fFlashChi2;

  //Invariant Mass of all 2-photon pairs
  std::vector<float> _fTwoPhotonInvariantMass;
  
  //Candidate track & vertex
  float _fCandidateVertexX;
  float _fCandidateVertexY;
  float _fCandidateVertexZ;
  
  int   _fCandidateMuonTrueComposition;
  int   _fCandidateMuonIsContained;
  float _fCandidateMuonDist3d;
  float _fCandidateMuonAng3d;
  float _fCandidateMuonPID;
  float _fCandidateMuonStartX;
  float _fCandidateMuonStartY;
  float _fCandidateMuonStartZ;
  float _fCandidateMuonEndX;
  float _fCandidateMuonEndY;
  float _fCandidateMuonEndZ;
  float _fCandidateMuonMomentum;
  float _fCandidateMuonMCSMomentum;
  float _fCandidateMuonRangeMomentum;
  float _fCandidateMuonLength;
  float _fCandidateMuonCostheta;
  float _fCandidateMuonPhi;
  float _fCandidateMuonThetaXZ;
  float _fCandidateMuonThetaYZ;
  float _fCandidateMuonMomentumResolution;
  float _fCandidateMuonRangeMomentumResolution;
  float _fCandidateMuonMCSMomentumResolution;
  float _fCandidateMuonAngleResolution;
  
  //Candidate pi0
  float _fCandidatePi0Momentum;
  float _fCandidatePi0Costheta;
  float _fCandidatePi0Phi;
  float _fCandidatePi0Mass;
  float _fCandidatePi0Energy;
  float _fCandidatePi0Angle12;
  float _fCandidatePi0MomentumResolution;
  float _fCandidatePi0AngleResolution;

  //Candidate photons
  int _fCandidateLeadTrueComposition;
  float _fCandidateLeadScore;
  float _fCandidateLeadLength;
  float _fCandidateLeadOpenAngle;
  float _fCandidateLeadCostheta;
  float _fCandidateLeadPhi;
  float _fCandidateLeadDirX;
  float _fCandidateLeadDirY;
  float _fCandidateLeadDirZ;
  float _fCandidateLeadThetaXZ;
  float _fCandidateLeadThetaYZ;
  float _fCandidateLeadDist3d;
  float _fCandidateLeadAng3d;
  float _fCandidateLeadStartX;
  float _fCandidateLeadStartY;
  float _fCandidateLeadStartZ;
  float _fCandidateLeadEnergy0;
  float _fCandidateLeadEnergy1;
  float _fCandidateLeadEnergy2;
  float _fCandidateLeaddEdx0;
  float _fCandidateLeaddEdx1;
  float _fCandidateLeaddEdx2;
  float _fCandidateLeaddEdx3;
  float _fCandidateLeadEnergy0Resolution;
  float _fCandidateLeadEnergy1Resolution;
  float _fCandidateLeadEnergy2Resolution;
  float _fCandidateLeadAngleResolution;
  float _fCandidateLeadPurity0;
  float _fCandidateLeadPurity1;
  float _fCandidateLeadPurity2;
  float _fCandidateLeadCompleteness0;
  float _fCandidateLeadCompleteness1;
  float _fCandidateLeadCompleteness2;

  int _fCandidateSubleadTrueComposition;
  float _fCandidateSubleadScore;
  float _fCandidateSubleadLength;
  float _fCandidateSubleadOpenAngle;
  float _fCandidateSubleadCostheta;
  float _fCandidateSubleadPhi;
  float _fCandidateSubleadDirX;
  float _fCandidateSubleadDirY;
  float _fCandidateSubleadDirZ;
  float _fCandidateSubleadThetaXZ;
  float _fCandidateSubleadThetaYZ;
  float _fCandidateSubleadDist3d;
  float _fCandidateSubleadAng3d;
  float _fCandidateSubleadStartX;
  float _fCandidateSubleadStartY;
  float _fCandidateSubleadStartZ;
  float _fCandidateSubleadEnergy0;
  float _fCandidateSubleadEnergy1;
  float _fCandidateSubleadEnergy2;
  float _fCandidateSubleaddEdx0;
  float _fCandidateSubleaddEdx1;
  float _fCandidateSubleaddEdx2;
  float _fCandidateSubleaddEdx3;
  float _fCandidateSubleadEnergy0Resolution;
  float _fCandidateSubleadEnergy1Resolution;
  float _fCandidateSubleadEnergy2Resolution;
  float _fCandidateSubleadAngleResolution;
  float _fCandidateSubleadPurity0;
  float _fCandidateSubleadPurity1;
  float _fCandidateSubleadPurity2;
  float _fCandidateSubleadCompleteness0;
  float _fCandidateSubleadCompleteness1;
  float _fCandidateSubleadCompleteness2;

  //2 MIP Sideband photons
  float _fTwoMIPPi0Momentum;
  float _fTwoMIPPi0Costheta;
  float _fTwoMIPPi0Phi;
  float _fTwoMIPPi0Mass;
  float _fTwoMIPPi0Energy;
  float _fTwoMIPPi0Angle12;
  float _fTwoMIPPi0MomentumResolution;
  float _fTwoMIPPi0AngleResolution;

  int _fTwoMIPLeadTrueComposition;
  float _fTwoMIPLeadScore;
  float _fTwoMIPLeadLength;
  float _fTwoMIPLeadOpenAngle;
  float _fTwoMIPLeadCostheta;
  float _fTwoMIPLeadPhi;
  float _fTwoMIPLeadDirZ;
  float _fTwoMIPLeadDirX;
  float _fTwoMIPLeadDirY;
  float _fTwoMIPLeadStartX;
  float _fTwoMIPLeadStartY;
  float _fTwoMIPLeadStartZ;
  float _fTwoMIPLeadThetaXZ;
  float _fTwoMIPLeadThetaYZ;
  float _fTwoMIPLeadDist3d;
  float _fTwoMIPLeadAng3d;
  float _fTwoMIPLeadEnergy0;
  float _fTwoMIPLeadEnergy1;
  float _fTwoMIPLeadEnergy2;
  float _fTwoMIPLeaddEdx0;
  float _fTwoMIPLeaddEdx1;
  float _fTwoMIPLeaddEdx2;
  float _fTwoMIPLeaddEdx3;
  float _fTwoMIPLeadEnergy0Resolution;
  float _fTwoMIPLeadEnergy1Resolution;
  float _fTwoMIPLeadEnergy2Resolution;
  float _fTwoMIPLeadAngleResolution;
  float _fTwoMIPLeadPurity0;
  float _fTwoMIPLeadPurity1;
  float _fTwoMIPLeadPurity2;
  float _fTwoMIPLeadCompleteness0;
  float _fTwoMIPLeadCompleteness1;
  float _fTwoMIPLeadCompleteness2;

  int _fTwoMIPSubleadTrueComposition;
  float _fTwoMIPSubleadScore;
  float _fTwoMIPSubleadLength;
  float _fTwoMIPSubleadOpenAngle;
  float _fTwoMIPSubleadCostheta;
  float _fTwoMIPSubleadPhi;
  float _fTwoMIPSubleadDirZ;
  float _fTwoMIPSubleadDirX;
  float _fTwoMIPSubleadDirY;
  float _fTwoMIPSubleadThetaXZ;
  float _fTwoMIPSubleadThetaYZ;
  float _fTwoMIPSubleadDist3d;
  float _fTwoMIPSubleadAng3d;
  float _fTwoMIPSubleadStartX;
  float _fTwoMIPSubleadStartY;
  float _fTwoMIPSubleadStartZ;
  float _fTwoMIPSubleadEnergy0;
  float _fTwoMIPSubleadEnergy1;
  float _fTwoMIPSubleadEnergy2;
  float _fTwoMIPSubleaddEdx0;
  float _fTwoMIPSubleaddEdx1;
  float _fTwoMIPSubleaddEdx2;
  float _fTwoMIPSubleaddEdx3;
  float _fTwoMIPSubleadEnergy0Resolution;
  float _fTwoMIPSubleadEnergy1Resolution;
  float _fTwoMIPSubleadEnergy2Resolution;
  float _fTwoMIPSubleadAngleResolution;
  float _fTwoMIPSubleadPurity0;
  float _fTwoMIPSubleadPurity1;
  float _fTwoMIPSubleadPurity2;
  float _fTwoMIPSubleadCompleteness0;
  float _fTwoMIPSubleadCompleteness1;
  float _fTwoMIPSubleadCompleteness2;

  //Multipair Sideband photons
  std::vector<float> _fMultiPairPi0Momentum;
  std::vector<float> _fMultiPairPi0Costheta;
  std::vector<float> _fMultiPairPi0Phi;
  std::vector<float> _fMultiPairPi0Mass;
  std::vector<float> _fMultiPairPi0Energy;
  std::vector<float> _fMultiPairPi0Angle12;
  std::vector<float> _fMultiPairPi0MomentumResolution;
  std::vector<float> _fMultiPairPi0AngleResolution;

  int _fMultiPairLeadTrueComposition;
  float _fMultiPairLeadScore;
  float _fMultiPairLeadLength;
  float _fMultiPairLeadOpenAngle;
  float _fMultiPairLeadCostheta;
  float _fMultiPairLeadPhi;
  float _fMultiPairLeadDirZ;
  float _fMultiPairLeadDirX;
  float _fMultiPairLeadDirY;
  float _fMultiPairLeadThetaXZ;
  float _fMultiPairLeadThetaYZ;
  float _fMultiPairLeadDist3d;
  float _fMultiPairLeadAng3d;
  float _fMultiPairLeadStartX;
  float _fMultiPairLeadStartY;
  float _fMultiPairLeadStartZ;
  float _fMultiPairLeadEnergy0;
  float _fMultiPairLeadEnergy1;
  float _fMultiPairLeadEnergy2;
  float _fMultiPairLeaddEdx0;
  float _fMultiPairLeaddEdx1;
  float _fMultiPairLeaddEdx2;
  float _fMultiPairLeaddEdx3;
  float _fMultiPairLeadEnergy0Resolution;
  float _fMultiPairLeadEnergy1Resolution;
  float _fMultiPairLeadEnergy2Resolution;
  float _fMultiPairLeadAngleResolution;
  float _fMultiPairLeadPurity0;
  float _fMultiPairLeadPurity1;
  float _fMultiPairLeadPurity2;
  float _fMultiPairLeadCompleteness0;
  float _fMultiPairLeadCompleteness1;
  float _fMultiPairLeadCompleteness2;

  //These need to be vectors
  std::vector<int>   _fMultiPairSubleadTrueComposition;
  std::vector<float> _fMultiPairSubleadScore;
  std::vector<float> _fMultiPairSubleadLength;
  std::vector<float> _fMultiPairSubleadOpenAngle;
  std::vector<float> _fMultiPairSubleadCostheta;
  std::vector<float> _fMultiPairSubleadPhi;
  std::vector<float> _fMultiPairSubleadDirZ;
  std::vector<float> _fMultiPairSubleadDirX;
  std::vector<float> _fMultiPairSubleadDirY;
  std::vector<float> _fMultiPairSubleadThetaXZ;
  std::vector<float> _fMultiPairSubleadThetaYZ;
  std::vector<float> _fMultiPairSubleadDist3d;
  std::vector<float> _fMultiPairSubleadAng3d;
  std::vector<float> _fMultiPairSubleadStartX;
  std::vector<float> _fMultiPairSubleadStartY;
  std::vector<float> _fMultiPairSubleadStartZ;
  std::vector<float> _fMultiPairSubleadEnergy0;
  std::vector<float> _fMultiPairSubleadEnergy1;
  std::vector<float> _fMultiPairSubleadEnergy2;
  std::vector<float> _fMultiPairSubleaddEdx0;
  std::vector<float> _fMultiPairSubleaddEdx1;
  std::vector<float> _fMultiPairSubleaddEdx2;
  std::vector<float> _fMultiPairSubleaddEdx3;
  std::vector<float> _fMultiPairSubleadEnergy0Resolution;
  std::vector<float> _fMultiPairSubleadEnergy1Resolution;
  std::vector<float> _fMultiPairSubleadEnergy2Resolution;
  std::vector<float> _fMultiPairSubleadAngleResolution;
  std::vector<float> _fMultiPairSubleadPurity0;
  std::vector<float> _fMultiPairSubleadPurity1;
  std::vector<float> _fMultiPairSubleadPurity2;
  std::vector<float> _fMultiPairSubleadCompleteness0;
  std::vector<float> _fMultiPairSubleadCompleteness1;
  std::vector<float> _fMultiPairSubleadCompleteness2;

  //Hi Mass Sideband photons
  float _fHiMassPi0Momentum;
  float _fHiMassPi0Costheta;
  float _fHiMassPi0Phi;
  float _fHiMassPi0Mass;
  float _fHiMassPi0Energy;
  float _fHiMassPi0Angle12;
  float _fHiMassPi0MomentumResolution;
  float _fHiMassPi0AngleResolution;

  int _fHiMassLeadTrueComposition;
  float _fHiMassLeadScore;
  float _fHiMassLeadLength;
  float _fHiMassLeadOpenAngle;
  float _fHiMassLeadCostheta;
  float _fHiMassLeadPhi;
  float _fHiMassLeadDirZ;
  float _fHiMassLeadDirX;
  float _fHiMassLeadDirY;  
  float _fHiMassLeadThetaXZ;
  float _fHiMassLeadThetaYZ;
  float _fHiMassLeadDist3d;
  float _fHiMassLeadAng3d;
  float _fHiMassLeadStartX;
  float _fHiMassLeadStartY;
  float _fHiMassLeadStartZ;
  float _fHiMassLeadEnergy0;
  float _fHiMassLeadEnergy1;
  float _fHiMassLeadEnergy2;
  float _fHiMassLeaddEdx0;
  float _fHiMassLeaddEdx1;
  float _fHiMassLeaddEdx2;
  float _fHiMassLeaddEdx3;
  float _fHiMassLeadEnergy0Resolution;
  float _fHiMassLeadEnergy1Resolution;
  float _fHiMassLeadEnergy2Resolution;
  float _fHiMassLeadAngleResolution;
  float _fHiMassLeadPurity0;
  float _fHiMassLeadPurity1;
  float _fHiMassLeadPurity2;
  float _fHiMassLeadCompleteness0;
  float _fHiMassLeadCompleteness1;
  float _fHiMassLeadCompleteness2;

  int _fHiMassSubleadTrueComposition;
  float _fHiMassSubleadScore;
  float _fHiMassSubleadLength;
  float _fHiMassSubleadOpenAngle;
  float _fHiMassSubleadCostheta;
  float _fHiMassSubleadPhi;
  float _fHiMassSubleadDirZ;
  float _fHiMassSubleadDirX;
  float _fHiMassSubleadDirY; 
  float _fHiMassSubleadThetaXZ;
  float _fHiMassSubleadThetaYZ;
  float _fHiMassSubleadDist3d;
  float _fHiMassSubleadAng3d;
  float _fHiMassSubleadStartX;
  float _fHiMassSubleadStartY;
  float _fHiMassSubleadStartZ;
  float _fHiMassSubleadEnergy0;
  float _fHiMassSubleadEnergy1;
  float _fHiMassSubleadEnergy2;
  float _fHiMassSubleaddEdx0;
  float _fHiMassSubleaddEdx1;
  float _fHiMassSubleaddEdx2;
  float _fHiMassSubleaddEdx3;
  float _fHiMassSubleadEnergy0Resolution;
  float _fHiMassSubleadEnergy1Resolution;
  float _fHiMassSubleadEnergy2Resolution;
  float _fHiMassSubleadAngleResolution;
  float _fHiMassSubleadPurity0;
  float _fHiMassSubleadPurity1;
  float _fHiMassSubleadPurity2;
  float _fHiMassSubleadCompleteness0;
  float _fHiMassSubleadCompleteness1;
  float _fHiMassSubleadCompleteness2;


  //All tracks
  std::vector<int>   _fTrackTrueComposition;
  std::vector<int>   _fTrackIsContained;
  std::vector<float> _fTrackDist3d;
  std::vector<float> _fTrackAng3d;
  std::vector<float> _fTrackPID;
  std::vector<float> _fTrackStartX;
  std::vector<float> _fTrackStartY;
  std::vector<float> _fTrackStartZ;
  std::vector<float> _fTrackEndX;
  std::vector<float> _fTrackEndY;
  std::vector<float> _fTrackEndZ;
  std::vector<float> _fTrackMomentum;
  std::vector<float> _fTrackMCSMomentum;
  std::vector<float> _fTrackRangeMomentum;
  std::vector<float> _fTrackLength;
  std::vector<float> _fTrackCostheta;
  std::vector<float> _fTrackPhi;
  std::vector<float> _fTrackThetaXZ;
  std::vector<float> _fTrackThetaYZ;

  //All showers
  std::vector<int> _fShowerTrueComposition;
  std::vector<float> _fTrackShowerScore;
  std::vector<float> _fShowerLength;
  std::vector<float> _fShowerOpenAngle;
  std::vector<float> _fShowerCostheta;
  std::vector<float> _fShowerPhi;
  std::vector<float> _fShowerThetaXZ;
  std::vector<float> _fShowerThetaYZ;
  std::vector<float> _fShowerDist3d;
  std::vector<float> _fShowerAng3d;
  std::vector<float> _fShowerStartX;
  std::vector<float> _fShowerStartY;
  std::vector<float> _fShowerStartZ;
  std::vector<float> _fShowerEnergy0;
  std::vector<float> _fShowerEnergy1;
  std::vector<float> _fShowerEnergy2;
  std::vector<float> _fShowerdEdx0;
  std::vector<float> _fShowerdEdx1;
  std::vector<float> _fShowerdEdx2;
  std::vector<float> _fShowerdEdx3;
  std::vector<float> _fShowerEnergy0Resolution;
  std::vector<float> _fShowerEnergy1Resolution;
  std::vector<float> _fShowerEnergy2Resolution;
  std::vector<float> _fShowerAngleResolution;
  std::vector<float> _fShowerPurity0;
  std::vector<float> _fShowerPurity1;
  std::vector<float> _fShowerPurity2;
  std::vector<float> _fShowerCompleteness0;
  std::vector<float> _fShowerCompleteness1;
  std::vector<float> _fShowerCompleteness2;
  std::vector<float> _fShowerdDirX;
  std::vector<float> _fShowerdDirY;
  std::vector<float> _fShowerdDirZ;
  int   _fLeadShowerIDX;
  int   _fSubLeadShowerIDX;

  //Cut variables
  int _fHasCandidateNeutrino; // should be 1
  int _fHasCandidateMuon; // should be 1
  int _fNChargedPiCandidates; //should be 0
  int _fNProtonCandidates; // should be 0
  int _fNLeadCandidates; //should be 1
  int _fNSubleadCandidates; //should be 1
  int _fNPi0Candidates; //should be 1
  int _fNPairCandidates; //should be 1
  int _fNOtherFancyPairs; //should be 0
  int _fNHiMassPairs;
  //Add one for high mass pairs?

  int NALL;
  int NNEUTRINO;

  //Enums

  //DETECTOR SERVICES
  detinfo::DetectorProperties const * theDetector ;// = lar::providerFrom<detinfo::DetectorPropertiesService>();
  detinfo::DetectorClocks    const *  detClocks   ;//= lar::providerFrom<detinfo::DetectorClocksService>();
  //spacecharge::SpaceCharge const * SCE;
  geo::GeometryCore const * geom;

  //Mass Cuts
  double signalMassLow; //60
  double signalMassHigh; //180
  double sidebandMassHigh;
  double sidebandMassLow;

  //Shower Cuts
  double minConversionDist; 
  double maxConversionDist;
  double minYPlaneEnergy;
  double maxYPlaneEnergy;
  double minRadialAngle;

  //CONSTANTS
  int m_Cryostat;
  int m_TPC;
  double m_wire_spacing;
  double m_width_dqdx_box;
  double m_length_dqdx_box;
  double _time2cm;
  int m_planes;

  //COUNTING
  int Gamma1_E1_id;
  int Gamma1_E2_id;
  int Gamma2_E1_id;
  int Gamma2_E2_id;

  int n_0_0;
  int n_0_sh;
  int n_sh_0;
  int n_sh_sh;
  int n_0_t;
  int n_t_0;
  int n_t_t;
  int n_t_sh;
  int n_sh_t;

  float dist3d_min;
  float dist3d_max;
  float ang3d_min;
  float energy2_min;

  float bias_2;
  float altbias_2;

  float overlay_gain[3]; //for overlay
  float data_gain[3]; //for data

  int nexiting;
  int ncontained;
   
};

DEFINE_ART_MODULE(SidebandTree)